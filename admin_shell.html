<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin-Dashboard wird geladen...</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="cosmic-background"></div>
    <div class="container">
        <div class="loading-indicator" style="text-align: center; margin-top: 5rem;">
            <h2><span class="glitch" data-text="Entschlüssle Admin-Modul...">Entschlüssle Admin-Modul...</span></h2>
            <p id="decrypt-status"></p>
        </div>
    </div>

    <script>
        // Globale Konfiguration für die entschlüsselte Admin-Seite
        // Muss mit script.js übereinstimmen
        window.API_URL = 'https://script.google.com/macros/s/AKfycbwTo-adYNFp-jNQ4IBbPK-ZtTlErj_WMDFDSuUdsz94MDqnbpNYUdIVZsDDDWz4cwOtpg/exec';

        // Führt ALLE Skripte aus der entschlüsselten Seite in richtiger Reihenfolge aus.
        async function renderDecryptedPage(htmlContent) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');

            // 1) Ersetze den Body-Inhalt der entschlüsselten Seite (dies entfernt ursprüngliche <script>-Tags im DOM)
            document.body.innerHTML = doc.body.innerHTML;

            // 2) Sammle alle Skripte aus der entschlüsselten Seite
            const scripts = Array.from(doc.querySelectorAll('script'));

            // 3) Führe Skripte nacheinander aus, um die Reihenfolge zu erhalten
            for (const oldScript of scripts) {
                const newScript = document.createElement('script');

                // Kopiere Typ, falls gesetzt (z. B. type="module")
                if (oldScript.type) {
                    newScript.type = oldScript.type;
                }

                // Externe Skripte: lade und warte, dann erst nächstes Script
                if (oldScript.src) {
                    newScript.src = oldScript.src;
                    // async/defer explizit deaktivieren, um Reihenfolge zu garantieren
                    newScript.async = false;
                    await new Promise((resolve, reject) => {
                        newScript.onload = resolve;
                        newScript.onerror = reject;
                        document.body.appendChild(newScript);
                    });
                } else {
                    // Inline-Skripte:
                    // - Für Module: unverändert einsetzen (unterstützt Top-Level await nativ)
                    // - Für normale Skripte: in async IIFE wrappen, um Top-Level await zu ermöglichen,
                    //   ohne den globalen Scope zu "verschmutzen".
                    const content = oldScript.textContent || '';
                    if (newScript.type === 'module') {
                        newScript.textContent = content;
                    } else {
                        newScript.textContent = `(async () => { ${content} })();`;
                    }
                    document.body.appendChild(newScript);
                    // Inline-Skripte laufen synchron, kein explizites Warten notwendig
                }
            }
        }

        async function decryptAndLoad() {
            const status = document.getElementById('decrypt-status');
            const username = sessionStorage.getItem('crypto-user');
            const password = sessionStorage.getItem('crypto-pass');

            if (!username || !password) {
                window.location.href = 'login.html';
                return;
            }

            try {
                status.textContent = "Lade verschlüsselte Daten...";
                const response = await fetch('admin.dat');
                if (!response.ok) throw new Error("Verschlüsselte Datei 'admin.dat' nicht gefunden.");

                const encryptedDataB64 = await response.text();
                const combined = new Uint8Array(atob(encryptedDataB64).split('').map(char => char.charCodeAt(0)));

                const salt = combined.slice(0, 16);
                const iv = combined.slice(16, 28);
                const encrypted = combined.slice(28);

                status.textContent = "Generiere Entschlüsselungscode...";
                const keyMaterial = await crypto.subtle.importKey(
                    "raw",
                    new TextEncoder().encode(password + username),
                    { name: "PBKDF2" },
                    false,
                    ["deriveKey"]
                );

                const key = await crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt: salt, iterations: 100000, hash: "SHA-256" },
                    keyMaterial,
                    { name: "AES-GCM", length: 256 },
                    true,
                    ["encrypt", "decrypt"]
                );

                status.textContent = "Entschlüssle Daten...";
                const decrypted = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    encrypted
                );

                status.textContent = "Lade Admin-Oberfläche...";
                const decryptedHtml = new TextDecoder().decode(decrypted);

                // Sicherheit: Entferne die Entschlüsselungsdaten aus der Session
                sessionStorage.removeItem('crypto-user');
                sessionStorage.removeItem('crypto-pass');

                await renderDecryptedPage(decryptedHtml);
            } catch (err) {
                console.error("Entschlüsselung fehlgeschlagen:", err);
                status.innerHTML = `Entschlüsselung fehlgeschlagen. Wahrscheinlich falscher Benutzername/Passwort. <a href="login.html">Erneut versuchen</a>.`;
                sessionStorage.clear();
            }
        }

        decryptAndLoad();
    </script>
</body>
</html>